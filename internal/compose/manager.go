package compose

import (
	"fmt"
	"os"
	"path/filepath"
)

type Manager struct {
	basePath string
}

type ProjectConfig struct {
	Name        string            `json:"name"`
	ComposeFile string            `json:"compose_file,omitempty"` // Optional, defaults to docker-compose.yml
	Content     string            `json:"content"`                // Docker compose YAML content
	EnvVars     map[string]string `json:"env_vars,omitempty"`     // Environment variables for .env file
	Override    bool              `json:"override,omitempty"`     // Whether to override existing files
}

func NewManager(basePath string) *Manager {
	return &Manager{
		basePath: basePath,
	}
}

// EnsureBaseDirectory creates the base compose directory if it doesn't exist
func (m *Manager) EnsureBaseDirectory() error {
	if err := os.MkdirAll(m.basePath, 0755); err != nil {
		return fmt.Errorf("failed to create base directory %s: %w", m.basePath, err)
	}
	return nil
}

// CreateProject creates a new compose project directory with files
func (m *Manager) CreateProject(config ProjectConfig) error {
	if config.Name == "" {
		return fmt.Errorf("project name is required")
	}

	if config.Content == "" {
		return fmt.Errorf("compose content is required")
	}

	// Set default compose file name
	if config.ComposeFile == "" {
		config.ComposeFile = "docker-compose.yml"
	}

	projectPath := filepath.Join(m.basePath, config.Name)

	// Create project directory
	if err := os.MkdirAll(projectPath, 0755); err != nil {
		return fmt.Errorf("failed to create project directory %s: %w", projectPath, err)
	}

	// Create compose file
	composeFilePath := filepath.Join(projectPath, config.ComposeFile)
	if err := m.writeFileIfNotExists(composeFilePath, config.Content, config.Override); err != nil {
		return fmt.Errorf("failed to create compose file: %w", err)
	}

	// Create .env file if env vars provided
	if len(config.EnvVars) > 0 {
		envFilePath := filepath.Join(projectPath, ".env")
		envContent := m.generateEnvContent(config.EnvVars)
		if err := m.writeFileIfNotExists(envFilePath, envContent, config.Override); err != nil {
			return fmt.Errorf("failed to create .env file: %w", err)
		}
	}

	return nil
}

// UpdateProject updates an existing project's files
func (m *Manager) UpdateProject(config ProjectConfig) error {
	config.Override = true // Force override for updates
	return m.CreateProject(config)
}

// DeleteProject removes a project directory
func (m *Manager) DeleteProject(projectName string) error {
	if projectName == "" {
		return fmt.Errorf("project name is required")
	}

	projectPath := filepath.Join(m.basePath, projectName)

	// Check if project exists
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		return fmt.Errorf("project %s does not exist", projectName)
	}

	// Remove project directory
	if err := os.RemoveAll(projectPath); err != nil {
		return fmt.Errorf("failed to delete project %s: %w", projectName, err)
	}

	return nil
}

// ListProjects returns a list of existing project names
func (m *Manager) ListProjects() ([]string, error) {
	entries, err := os.ReadDir(m.basePath)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read base directory: %w", err)
	}

	var projects []string
	for _, entry := range entries {
		if entry.IsDir() {
			projects = append(projects, entry.Name())
		}
	}

	return projects, nil
}

// ProjectExists checks if a project directory exists
func (m *Manager) ProjectExists(projectName string) bool {
	projectPath := filepath.Join(m.basePath, projectName)
	_, err := os.Stat(projectPath)
	return !os.IsNotExist(err)
}

// GetProjectPath returns the full path to a project directory
func (m *Manager) GetProjectPath(projectName string) string {
	return filepath.Join(m.basePath, projectName)
}

// GetComposePath returns the full path to a project's compose file
func (m *Manager) GetComposePath(projectName, composeFile string) string {
	if composeFile == "" {
		composeFile = "docker-compose.yml"
	}
	return filepath.Join(m.basePath, projectName, composeFile)
}

// writeFileIfNotExists writes content to a file, optionally overriding existing files
func (m *Manager) writeFileIfNotExists(filePath, content string, override bool) error {
	// Check if file exists
	if _, err := os.Stat(filePath); err == nil && !override {
		return fmt.Errorf("file %s already exists and override is false", filePath)
	}

	// Write file
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filePath, err)
	}

	return nil
}

// generateEnvContent creates .env file content from environment variables
func (m *Manager) generateEnvContent(envVars map[string]string) string {
	content := "# Environment variables for Docker Compose\n"
	content += "# Generated by Arcane Agent\n\n"

	for key, value := range envVars {
		content += fmt.Sprintf("%s=%s\n", key, value)
	}

	return content
}
